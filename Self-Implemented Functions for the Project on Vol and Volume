##################################### Load Data #####################################################
Open2Close_vol <- function(tab_ohlc, date) {
  # Compute the Open-Close daily volatility for a OHCL format data frame.  
  #
  # Args:
  #   tab_ohlc: a data frame, consisting of daily open, high, low and close. 
  #   date: a list of "Date" objects or character strings represent the dates. 
  #
  # Returns:
  #   A xts object of daily volatitlity. 
  if (anyNA(tab_ohlc)) {
    tab_ohcl[is.na(tab_ohlc)] <- 0
  }
  # Compute the daily Open-Close return series. 
  ret <- ifelse(tab_ohlc$Open != 0, (tab_ohlc$Close - tab_ohlc$Open) / tab_ohlc$Open, 0)
  ret <- xts(ret, order.by = as.Date(date))
  # Extract the daily volatility. 
  v <- rollapply(ret, width = 10, FUN = sd)[-(1 : 10)] * sqrt(252)
  
  return(v)
}

Get_Stock <- function(ticker, exchange, n_days) {
  # Get the daily volatility and volume data for a particular ticker,
  # given a prespecified length of period.  
  #
  # Args:
  #   ticker: a character string, representing the ticker. 
  #   exchange: a character string, representing the exchange,
  #             from which the ticker can be found, either "SES" or "NSI"
  #   n_days: an integer, specifying the length of volatility and volume series;
  #           this variable is added to exclude some tickers have too few records. 
  #
  # Returns:
  #   A list of two xts objects, in vector form,
  #   representing the daily volatility and volume series. 
  print(ticker)
  
  # Select the table for the specific ticker and exchange. 
  tab <- tryCatch(execute(h, paste0("select from ", exchange, "2 where Ticker = `", ticker)), 
                  error = function(e) NULL)
  # Skip the ticker, if we cannot pull the data out from the database,
  # possibly due to special symobls contained in the ticker, e.g. M&MFIN4.BO.
  if (is.null(tab)) {
    return(NULL)
  }
  # Remove any duplicated columns, 
  # which are possible to exit when downloading from Yahoo Finance, e.g. BLR.SI. 
  # We have to assume that the rows with duplicated time index have the same content, 
  # in order to avoid manual checking. 
  tab <- tab[!duplicated(tab$Date), ]
  
  # Only if the length of the data equals the period of interest, we add them.
  # It is not necessary to consider stocks that are too new. 
  if (dim(tab)[1] != n_days[exchange]) {
    return(NULL)
  }
  
  # If the stock price is never above 0.05, skip this stock. 
  if (max(na.omit(tab$Close)) < 0.05) {
    return(NULL)
  }
  
  # Get the OHCL object. 
  tab_ohlc <- tab[, 1 : 6]
  
  # If there are over 30% of the data are missing, disgard the ticker. 
  if (sum(is.na(tab_ohlc)) > 0.3 * dim(tab_ohlc)[1] * 6) {
    return(NULL)
  }
  
  # Impute the missing values. 
  if (anyNA(tab_ohlc)) {
    tab_ohlc[is.na(tab_ohlc)] <- 0.0
  }
  
  # Compute the daily volatility
  vol <- Open2Close_vol(tab_ohlc, date = tab$Date)
  # There is NA in the final output of the rolling volatility series,
  # drop the whole series and return NULL.
  # The reason is that there are too many 0's in the return series, 
  # and there is hardly any volatility. 
  #if (anyNA(vol)) {
  #  return(NULL)
  #}
  chartSeries(vol) 
  names(vol) <- ticker
  
  # Extract the daily volume. 
  v2 <- tab_ohlc[['Volume']]
  volume <- as.xts(v2, order.by = as.Date(tab[['Date']]))
  volume <- window(volume, start = first(index(vol)))
  chartSeries(volume) 
  names(volume) <- ticker
  
  return(list(vol = vol, volume = volume))
}

Get_Exchange <- function(exchange) {
  # Get the daily volatility and volume data for all the tickers, 
  # for a particular exchange. 
  #
  # Args:
  #   exchange: a character string, representing the exchange,
  #             from which the ticker can be found, either "SES" or "NSI"
  #
  # Returns:
  #   A list of two xts objects, in matrix form, 
  #   representing the daily volatility and volume series. 
  tickers <- unique(execute(h, paste0("select Ticker from ", exchange, '2'))[[1]])
 
  res <- lapply(tickers, partial(Get_Stock, exchange = exchange, n_days = n_days[exchange]))
  res2 <- lapply(c('vol', 'volume'), function(c) Reduce(cbind, lapply(res, function(x) x[[c]])))
  
  return(list(vol = res2[[1]], volume = res2[[2]]))
}

##################################### Functional Data Analysis ######################################
ReadData <- function(x) {
  # Read data from csv files using data.table::fread and separte them into 3. 
  #
  # Args:
  #   x: integer, ranging from 1 to 5, indicating which csv file to load. 
  #
  # Returns:
  #   A list of three data frames, corresponding to time, price and volumn. 
  # Read data using fread. 
  d <- fread(paste("//bach.local/hongkong/Users$/mzeng//OneDrive/Documents/SPX", 
             x, "M.csv", sep = ""), header = T, sep = ",", data.table = F)
  # Separate the data into three parts. 
  n <- length(d)
  lapply(1 : 3, function(x) d[seq(x, n, 4)])
}

ChooseLambda <- function(x, y, basis, lfd, argvals, data) {
  # Compute GCV value corresponding to a specific value of lambda.
  #
  # Args:
  #   x: index specifing the position in y. 
  #   y: a numeric vector containing log10 of lambda, by default, loglam.
  #   basis: an object of class basisfd, by default, dayBasis.
  #   lfd: an object of calss Lfd, by default, harmaccelLfd, or an integer. 
  #   argvals: same as argvals in smooth.basis. 
  #   data: a matrix with columns representing functional observations.
  #
  # Returns:
  #   GCV value corresponding to the specific lambda value, 10 ^ y[x].
  cat(paste('log 10 lambda =', y[x], '\n'))
  #Compute lambda.
  lambda <- 10 ^ y[x]

  #Define a fdPar object.
  fdParobj <- fdPar(basis, lfd, lambda)

  #Soomth the data using fdPar.
  smoothlist <- smooth.basis(argvals, data, fdParobj)

  #Sum the GCV values up, as sooth.basis returns a vector of GCV values, 
  #one for each curve. 
  gcvSum <- sum(smoothlist$gcv)
}

OptiPC <- function(x, y, neig = 2) {
  # Plot eigenvalue vs eigenvalue numbers to determine how many PC's to retain. 
  #
  # Args:
  #   y: a numeric scalar, indicating a specific number of eigenvalues of interests. 
  #   x: an object of class pca.fd, by default logPrecRotatePCAList.   
  #   neig: total number of eigenvalues to be considered, by default 12. 
  #
  # Returns:
  #   A plot with a regression line fitted by the remaining PC's eigenvalues. 
  cat(paste('Eigenvalue Number =', x, '\n'))
  # Extract the complete set of eigenvalues from a pca.fd object. 
  fdaEig <- y$values
  index <- 1 : neig
  index2 <- (x + 1) : neig

  dm <- matrix(1, neig - x, 2)
  dm[, 2] <- index2
  resp <- log10(fdaEig[index2])
  fit <- lsfit(dm, resp, int = FALSE)$coef

  plot(index, log10(fdaEig[index]), "b", xlab = "Eigenvalue Number",
       ylab = "Log10 Eigenvalue")
  lines(index, fit[1] + fit[2] * index, lty = 2)
}
